{"version":3,"sources":["mvc/decorators/method/route.ts"],"names":[],"mappings":"AAEA;;;;;;;;;;;;GAYG;AACH,wBAAgB,GAAG,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,CAEzE;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,GAAG,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,CAEzE;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,IAAI,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,CAE1E;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,GAAG,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,CAEzE;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,MAAM,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,CAE5E;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,IAAI,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,CAE1E;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,KAAK,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,CAE3E","file":"route.d.ts","sourcesContent":["import {Use} from \"./use\";\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n */\nexport function All(path: string | RegExp | any, ...args: any[]): Function {\n  return Use(...[\"all\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n */\nexport function Get(path: string | RegExp | any, ...args: any[]): Function {\n  return Use(...[\"get\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n */\nexport function Post(path: string | RegExp | any, ...args: any[]): Function {\n  return Use(...[\"post\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n */\nexport function Put(path: string | RegExp | any, ...args: any[]): Function {\n  return Use(...[\"put\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n */\nexport function Delete(path: string | RegExp | any, ...args: any[]): Function {\n  return Use(...[\"delete\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n */\nexport function Head(path: string | RegExp | any, ...args: any[]): Function {\n  return Use(...[\"head\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n */\nexport function Patch(path: string | RegExp | any, ...args: any[]): Function {\n  return Use(...[\"patch\", path].concat(args));\n}\n"],"sourceRoot":"../../../../src"}