{"version":3,"sources":["mvc/class/EndpointBuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,eAAe,EAAC,MAAM,UAAU,CAAC;AAEzC,OAAO,EAAC,gBAAgB,EAAC,MAAM,oBAAoB,CAAC;AAGpD;;GAEG;AACH,qBAAa,eAAe;IACd,OAAO,CAAC,QAAQ;IAAoB,OAAO,CAAC,MAAM;gBAA1C,QAAQ,EAAE,gBAAgB,EAAU,MAAM,EAAE,GAAG;IAEnE;;OAEG;IACH,OAAO,CAAC,WAAW;IAqBnB,OAAO,CAAC,aAAa;IAwBrB;;;OAGG;IACH,OAAO,CAAC,gBAAgB;IAexB;;;;OAIG;IACH,KAAK,CAAC,QAAQ,EAAE,eAAe;CAmBhC","file":"EndpointBuilder.d.ts","sourcesContent":["import {applyBefore, nameOf} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport {SendResponseMiddleware} from \"../components/SendResponseMiddleware\";\nimport {EndpointMetadata} from \"./EndpointMetadata\";\nimport {HandlerBuilder} from \"./HandlerBuilder\";\n\n/**\n *\n */\nexport class EndpointBuilder {\n  constructor(private endpoint: EndpointMetadata, private router: any) {}\n\n  /**\n   *\n   */\n  private bindRequest(endpoint: EndpointMetadata, debug: boolean) {\n    return (request: any, response: any, next: any) => {\n      /* istanbul ignore else */\n      if (request.id && debug) {\n        request.log.debug({\n          event: \"bind.request\",\n          target: nameOf(endpoint.target),\n          methodClass: endpoint.methodClassName,\n          httpMethod: request.method\n        });\n      }\n\n      request.createContainer();\n      request.setEndpoint(endpoint);\n\n      applyBefore(response, \"end\", () => this.unbindRequest(endpoint, debug, request));\n\n      next();\n    };\n  }\n\n  private unbindRequest(endpoint: EndpointMetadata, debug: boolean, request: any) {\n    /* istanbul ignore next */\n    if (request.id && debug) {\n      request.log.debug({\n        event: \"unbind.request\",\n        target: nameOf(endpoint.target),\n        methodClass: endpoint.methodClassName,\n        httpMethod: request.method\n      });\n    }\n\n    try {\n      request.destroyContainer();\n      request.destroyEndpoint();\n    } catch (error) {\n      request.log.error({\n        error: {\n          message: \"Unable to clean request. \" + error.message,\n          stack: error.stack\n        }\n      });\n    }\n  }\n\n  /**\n   *\n   * @param middlewares\n   */\n  private routeMiddlewares(middlewares: any[]) {\n    this.endpoint.pathsMethods.forEach(({path, method}) => {\n      if (!!method && this.router[method]) {\n        this.router[method](path, ...middlewares);\n      } else {\n        const args: any[] = [path].concat(middlewares);\n        this.router.use(...args);\n      }\n    });\n\n    if (!this.endpoint.pathsMethods.length) {\n      this.router.use(...middlewares);\n    }\n  }\n\n  /**\n   *\n   * @returns {any[]}\n   * @param injector\n   */\n  build(injector: InjectorService) {\n    const endpoint = this.endpoint;\n    const debug = injector.settings.debug;\n\n    let middlewares: any = []\n      .concat(endpoint.beforeMiddlewares as any)\n      .concat(endpoint.middlewares as any)\n      .concat([endpoint] as any)\n      .concat(endpoint.afterMiddlewares as any)\n      .concat(SendResponseMiddleware as any)\n      .filter((item: any) => !!item)\n      .map((middleware: any) => HandlerBuilder.from(middleware).build(injector));\n\n    middlewares = [this.bindRequest(endpoint, debug)].concat(middlewares);\n\n    this.routeMiddlewares(middlewares);\n\n    return middlewares;\n  }\n}\n"],"sourceRoot":"../../../src"}