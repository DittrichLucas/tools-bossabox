"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@tsed/core");
const SendResponseMiddleware_1 = require("../components/SendResponseMiddleware");
const HandlerBuilder_1 = require("./HandlerBuilder");
/**
 *
 */
class EndpointBuilder {
    constructor(endpoint, router) {
        this.endpoint = endpoint;
        this.router = router;
    }
    /**
     *
     */
    bindRequest(endpoint, debug) {
        return (request, response, next) => {
            /* istanbul ignore else */
            if (request.id && debug) {
                request.log.debug({
                    event: "bind.request",
                    target: core_1.nameOf(endpoint.target),
                    methodClass: endpoint.methodClassName,
                    httpMethod: request.method
                });
            }
            request.createContainer();
            request.setEndpoint(endpoint);
            core_1.applyBefore(response, "end", () => this.unbindRequest(endpoint, debug, request));
            next();
        };
    }
    unbindRequest(endpoint, debug, request) {
        /* istanbul ignore next */
        if (request.id && debug) {
            request.log.debug({
                event: "unbind.request",
                target: core_1.nameOf(endpoint.target),
                methodClass: endpoint.methodClassName,
                httpMethod: request.method
            });
        }
        try {
            request.destroyContainer();
            request.destroyEndpoint();
        }
        catch (error) {
            request.log.error({
                error: {
                    message: "Unable to clean request. " + error.message,
                    stack: error.stack
                }
            });
        }
    }
    /**
     *
     * @param middlewares
     */
    routeMiddlewares(middlewares) {
        this.endpoint.pathsMethods.forEach(({ path, method }) => {
            if (!!method && this.router[method]) {
                this.router[method](path, ...middlewares);
            }
            else {
                const args = [path].concat(middlewares);
                this.router.use(...args);
            }
        });
        if (!this.endpoint.pathsMethods.length) {
            this.router.use(...middlewares);
        }
    }
    /**
     *
     * @returns {any[]}
     * @param injector
     */
    build(injector) {
        const endpoint = this.endpoint;
        const debug = injector.settings.debug;
        let middlewares = []
            .concat(endpoint.beforeMiddlewares)
            .concat(endpoint.middlewares)
            .concat([endpoint])
            .concat(endpoint.afterMiddlewares)
            .concat(SendResponseMiddleware_1.SendResponseMiddleware)
            .filter((item) => !!item)
            .map((middleware) => HandlerBuilder_1.HandlerBuilder.from(middleware).build(injector));
        middlewares = [this.bindRequest(endpoint, debug)].concat(middlewares);
        this.routeMiddlewares(middlewares);
        return middlewares;
    }
}
exports.EndpointBuilder = EndpointBuilder;

//# sourceMappingURL=EndpointBuilder.js.map
