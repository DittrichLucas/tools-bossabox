{"version":3,"sources":["mvc/class/HandlerBuilder.ts"],"names":[],"mappings":"AAEA,OAAO,EAAgB,eAAe,EAAC,MAAM,UAAU,CAAC;AAIxD,OAAO,EAAC,gBAAgB,EAAC,MAAM,oBAAoB,CAAC;AACpD,OAAO,EAAC,eAAe,EAAC,MAAM,mBAAmB,CAAC;AAElD;;GAEG;AACH,qBAAa,cAAc;IAOb,OAAO,CAAC,eAAe;IANnC,OAAO,CAAC,OAAO,CAAQ;IACvB,OAAO,CAAC,QAAQ,CAAW;IAC3B,OAAO,CAAC,eAAe,CAAkB;IACzC,OAAO,CAAC,QAAQ,CAAkB;IAClC,OAAO,CAAC,KAAK,CAAU;gBAEH,eAAe,EAAE,eAAe;IAEpD;;;;OAIG;IACH,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,gBAAgB;IAUvC;;;OAGG;IACI,KAAK,CAAC,QAAQ,EAAE,eAAe;IAatC;;;;OAIG;IACH,OAAO,CAAC,YAAY;IAqBpB;;OAEG;IACH,OAAO,CAAC,UAAU;IAmBlB;;;;;;;OAOG;YACW,MAAM;IAsBpB;;;;;OAKG;IACH,OAAO,CAAC,GAAG;IAiBX;;;;;;OAMG;IACH,OAAO,CAAC,SAAS;IAgBjB;;;;;;OAMG;IACH,OAAO,CAAC,UAAU;CAUnB","file":"HandlerBuilder.d.ts","sourcesContent":["import {nameOf} from \"@tsed/core\";\nimport * as Express from \"express\";\nimport {ProviderScope, InjectorService} from \"@tsed/di\";\nimport {FilterBuilder} from \"../../filters/class/FilterBuilder\";\nimport {ParamMetadata} from \"../../filters/class/ParamMetadata\";\nimport {IFilterPreHandler} from \"../../filters/interfaces/IFilterPreHandler\";\nimport {EndpointMetadata} from \"./EndpointMetadata\";\nimport {HandlerMetadata} from \"./HandlerMetadata\";\n\n/**\n * @stable\n */\nexport class HandlerBuilder {\n  private filters: any[];\n  private _handler: Function;\n  private _rebuildHandler: boolean = false;\n  private injector: InjectorService;\n  private debug: boolean;\n\n  constructor(private handlerMetadata: HandlerMetadata) {}\n\n  /**\n   *\n   * @param obj\n   * @returns {HandlerBuilder}\n   */\n  static from(obj: any | EndpointMetadata) {\n    if (obj instanceof EndpointMetadata) {\n      // Endpoint\n      return new HandlerBuilder(new HandlerMetadata(obj.target, obj.methodClassName));\n    }\n\n    // Middleware\n    return new HandlerBuilder(new HandlerMetadata(obj));\n  }\n\n  /**\n   *\n   * @returns {any}\n   */\n  public build(injector: InjectorService) {\n    this.injector = injector;\n    this.debug = injector.settings.debug;\n\n    this.filters = this.handlerMetadata.services.map((param: ParamMetadata) => new FilterBuilder(injector).build(param));\n\n    if (this.handlerMetadata.errorParam) {\n      return (err: any, request: any, response: any, next: any) => this.invoke(request, response, next, err);\n    } else {\n      return (request: any, response: any, next: any) => this.invoke(request, response, next);\n    }\n  }\n\n  /**\n   *\n   * @param locals\n   * @returns {any}\n   */\n  private buildHandler<T>(locals: Map<string | Function, any> = new Map<string | Function, any>()): Function {\n    const provider = this.injector.getProvider(this.handlerMetadata.target);\n\n    /* istanbul ignore next */\n    if (!provider) {\n      throw new Error(`${nameOf(this.handlerMetadata.target)} component not found in the injector`);\n    }\n\n    const target = provider.useClass;\n    let instance = provider.instance;\n\n    this._rebuildHandler = provider.scope !== ProviderScope.SINGLETON;\n\n    if (this._rebuildHandler || instance === undefined) {\n      instance = this.injector.invoke<T>(target, locals, undefined, true);\n      locals.set(this.handlerMetadata.target, instance);\n    }\n\n    return instance[this.handlerMetadata.methodClassName!].bind(instance);\n  }\n\n  /**\n   *\n   */\n  private getHandler(locals: Map<string | Function, any> = new Map<string | Function, any>()): Function {\n    if (!this._rebuildHandler && this._handler) {\n      return this._handler;\n    }\n\n    switch (this.handlerMetadata.type) {\n      default:\n      case \"function\":\n        this._handler = this.handlerMetadata.target;\n        break;\n      case \"middleware\":\n      case \"controller\":\n        this._handler = this.buildHandler(locals);\n        break;\n    }\n\n    return this._handler;\n  }\n\n  /**\n   *\n   * @returns {Promise<TResult2|TResult1>}\n   * @param request\n   * @param response\n   * @param next\n   * @param err\n   */\n  private async invoke(request: Express.Request, response: Express.Response, next: any, err?: any): Promise<any> {\n    next = this.buildNext(request, response, next);\n\n    try {\n      this.log(request, {event: \"invoke.start\"});\n      const args = this.runFilters(request, response, next, err);\n      const result = await this.getHandler(request.getContainer())(...args);\n\n      if (!next.isCalled) {\n        if (this.handlerMetadata.type !== \"function\" && result !== undefined) {\n          request.storeData(result);\n        }\n\n        if (!this.handlerMetadata.nextFunction) {\n          next();\n        }\n      }\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  /**\n   *\n   * @param {Express.Request} request\n   * @param o\n   * @returns {string}\n   */\n  private log(request: Express.Request, o: any = {}) {\n    if (request.id && this.debug) {\n      const target = this.handlerMetadata.target;\n      const injectable = this.handlerMetadata.injectable;\n      const methodName = this.handlerMetadata.methodClassName;\n\n      request.log.debug({\n        type: this.handlerMetadata.type,\n        target: (target ? nameOf(target) : target.name) || \"anonymous\",\n        methodName,\n        injectable,\n        data: request && request.getStoredData ? request.getStoredData() : undefined,\n        ...o\n      });\n    }\n  }\n\n  /**\n   *\n   * @param {Express.Request} request\n   * @param {Express.Response} response\n   * @param {Express.NextFunction} next\n   * @returns {any}\n   */\n  private buildNext(request: Express.Request, response: Express.Response, next: any): any {\n    next.isCalled = false;\n\n    return (error?: any) => {\n      next.isCalled = true;\n      if (response.headersSent) {\n        return;\n      }\n\n      /* istanbul ignore else */\n      this.log(request, {event: \"invoke.end\", error});\n\n      return next(error);\n    };\n  }\n\n  /**\n   *\n   * @param request\n   * @param response\n   * @param next\n   * @param err\n   */\n  private runFilters(request: Express.Request, response: Express.Response, next: Express.NextFunction, err: any) {\n    return this.filters.map((filter: IFilterPreHandler) => {\n      return filter({\n        request,\n        response,\n        next,\n        err\n      });\n    });\n  }\n}\n"],"sourceRoot":"../../../src"}