{"version":3,"sources":["mvc/components/LogIncomingRequestMiddleware.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,OAAO,MAAM,SAAS,CAAC;AAGnC,OAAO,EAAC,qBAAqB,EAAC,MAAM,6CAA6C,CAAC;AAIlF,OAAO,EAAC,WAAW,EAAC,MAAM,eAAe,CAAC;AAE1C;;GAEG;AACH,qBACa,4BAA6B,YAAW,WAAW;IAC9D,OAAO,CAAC,MAAM,CAAC,cAAc,CAA0C;IAEvE,OAAO,CAAC,iBAAiB,CAAK;IAC9B,OAAO,CAAC,cAAc,CAAkB;IACxC,OAAO,CAAC,MAAM,CAAW;IACzB,OAAO,CAAC,YAAY,CAAe;IACnC,OAAO,CAAC,KAAK,CAAU;gBAGX,qBAAqB,EAAE,qBAAqB;IAOxD;;;;OAIG;IACI,GAAG,CAAQ,OAAO,EAAE,OAAO,CAAC,OAAO,EAAS,QAAQ,EAAE,OAAO,CAAC,QAAQ,GAAG,IAAI;IAQpF;;;OAGG;IACH,SAAS,CAAC,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO;IAI7C;;;OAGG;IACH,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO;IA0BnD;;;;OAIG;IACH,SAAS,CAAC,eAAe,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,GAAG,GAAG;IAaxD;;;;OAIG;IACH,SAAS,CAAC,oBAAoB,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,GAAG,GAAG;IAU7D;;;;OAIG;IACH,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,GAAG,MAAM;IAIvD;;;;;OAKG;IACH,SAAS,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,EAAE,gBAAgB,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,OAAO,KAAK,GAAG,GAAG,CAAC,KAAK,EAAE,GAAG,KAAK,MAAM;IAgBpH;;;;OAIG;IACH,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,CAAC,QAAQ;IAmBvE;;;OAGG;IACH,SAAS,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO;CAYhD","file":"LogIncomingRequestMiddleware.d.ts","sourcesContent":["import {applyBefore} from \"@tsed/core\";\nimport * as Express from \"express\";\nimport {$log} from \"ts-log-debug\";\nimport {ILoggerSettings} from \"../../config/interfaces/IServerSettings\";\nimport {ServerSettingsService} from \"../../config/services/ServerSettingsService\";\nimport {Req} from \"../../filters/decorators/request\";\nimport {Res} from \"../../filters/decorators/response\";\nimport {Middleware} from \"../decorators/class/middleware\";\nimport {IMiddleware} from \"../interfaces\";\n\n/**\n * @middleware\n */\n@Middleware()\nexport class LogIncomingRequestMiddleware implements IMiddleware {\n  private static DEFAULT_FIELDS = [\"reqId\", \"method\", \"url\", \"duration\"];\n\n  private AUTO_INCREMENT_ID = 1;\n  private loggerSettings: ILoggerSettings;\n  private fields: string[];\n  private reqIdBuilder: () => number;\n  private debug: boolean;\n\n  // tslint:disable-next-line: no-unused-variable\n  constructor(serverSettingsService: ServerSettingsService) {\n    this.loggerSettings = serverSettingsService.logger as ILoggerSettings;\n    this.reqIdBuilder = this.loggerSettings.reqIdBuilder || (() => this.AUTO_INCREMENT_ID++);\n    this.fields = this.loggerSettings.requestFields || LogIncomingRequestMiddleware.DEFAULT_FIELDS;\n    this.debug = serverSettingsService.debug;\n  }\n\n  /**\n   * Handle the request.\n   * @param {e.Request} request\n   * @param {e.Response} response\n   */\n  public use(@Req() request: Express.Request, @Res() response: Express.Response): void {\n    this.configureRequest(request);\n\n    this.onLogStart(request);\n\n    applyBefore(response, \"end\", () => this.onLogEnd(request, response));\n  }\n\n  /**\n   * The separate onLogStart() function will allow developer to overwrite the initial request log.\n   * @param {e.Request} request\n   */\n  protected onLogStart(request: Express.Request) {\n    request.log.debug({event: \"start\"});\n  }\n\n  /**\n   * Attach all informations that will be necessary to log the request. Attach a new `request.log` object.\n   * @param request\n   */\n  protected configureRequest(request: Express.Request) {\n    request.id = String(request.id ? request.id : this.reqIdBuilder());\n    request.tsedReqStart = new Date();\n\n    const {ignoreUrlPatterns = []} = this.loggerSettings;\n\n    const regs = ignoreUrlPatterns.map((pattern: string | RegExp) => (typeof pattern === \"string\" ? new RegExp(pattern, \"gi\") : pattern));\n\n    const verbose = (req: Express.Request) => this.requestToObject(req);\n    const info = (req: Express.Request) => this.minimalRequestPicker(req);\n\n    const run = (cb: Function) => {\n      const match = regs.find(reg => !!request.url.match(reg));\n\n      return !match && cb();\n    };\n\n    request.log = {\n      info: (obj: any) => run(() => $log.info(this.stringify(request, info)(obj))),\n      debug: (obj: any) => run(() => $log.debug(this.stringify(request, verbose)(obj))),\n      warn: (obj: any) => run(() => $log.warn(this.stringify(request, verbose)(obj))),\n      error: (obj: any) => run(() => $log.error(this.stringify(request, verbose)(obj))),\n      trace: (obj: any) => run(() => $log.trace(this.stringify(request, verbose)(obj)))\n    };\n  }\n\n  /**\n   * Return complete request info.\n   * @param request\n   * @returns {Object}\n   */\n  protected requestToObject(request: Express.Request): any {\n    return {\n      reqId: request.id,\n      method: request.method,\n      url: request.originalUrl || request.url,\n      duration: this.getDuration(request),\n      headers: request.headers,\n      body: request.body,\n      query: request.query,\n      params: request.params\n    };\n  }\n\n  /**\n   * Return a filtered request from global configuration.\n   * @param request\n   * @returns {Object}\n   */\n  protected minimalRequestPicker(request: Express.Request): any {\n    const info = this.requestToObject(request);\n\n    return this.fields.reduce((acc: any, key: string) => {\n      acc[key] = info[key];\n\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Return the duration between the time when LogIncomingRequest has handle the request and now.\n   * @param request\n   * @returns {number}\n   */\n  protected getDuration(request: Express.Request): number {\n    return new Date().getTime() - request.tsedReqStart.getTime();\n  }\n\n  /**\n   * Stringify a request to JSON.\n   * @param request\n   * @param propertySelector\n   * @returns {(scope: any) => string}\n   */\n  protected stringify(request: Express.Request, propertySelector: (e: Express.Request) => any): (scope: any) => string {\n    return (scope: any = {}) => {\n      if (typeof scope === \"string\") {\n        scope = {message: scope};\n      }\n      scope = Object.assign(scope, propertySelector(request));\n      try {\n        return JSON.stringify(scope, null, this.loggerSettings.jsonIndentation);\n      } catch (er) {\n        $log.error({error: er});\n      }\n\n      return \"\";\n    };\n  }\n\n  /**\n   * Called when the `request.end()` is called by Express.\n   * @param request\n   * @param response\n   */\n  protected onLogEnd(request: Express.Request, response: Express.Response) {\n    setImmediate(() => {\n      /* istanbul ignore else */\n      if (request.id) {\n        if (this.loggerSettings.logRequest) {\n          request.log.info({status: response.statusCode});\n        }\n\n        if (this.debug) {\n          request.log.debug({\n            status: response.statusCode,\n            data: request.getStoredData && request.getStoredData()\n          });\n        }\n        this.cleanRequest(request);\n      }\n    });\n  }\n\n  /**\n   * Remove all data that added with `LogIncomingRequest.configureRequest()`.\n   * @param request\n   */\n  protected cleanRequest(request: Express.Request) {\n    delete request.id;\n    delete request.tagId;\n    delete request.tsedReqStart;\n    request.log = {\n      info: () => {},\n      debug: () => {},\n      warn: () => {},\n      error: () => {},\n      trace: () => {}\n    };\n  }\n}\n"],"sourceRoot":"../../../src"}