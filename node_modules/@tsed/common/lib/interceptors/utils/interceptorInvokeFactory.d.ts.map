{"version":3,"sources":["interceptors/utils/interceptorInvokeFactory.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,IAAI,EAAC,MAAM,YAAY,CAAC;AAChC,OAAO,EAAC,eAAe,EAAC,MAAM,UAAU,CAAC;AACzC,OAAO,EAAC,YAAY,EAAC,MAAM,4BAA4B,CAAC;AAExD;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,IAAI,CAAC,GAAG,GAAG,YAAY,CAAC,EAAE,OAAO,CAAC,EAAE,GAAG,oDA0B5G","file":"interceptorInvokeFactory.d.ts","sourcesContent":["import {Type} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport {IInterceptor} from \"../interfaces/IInterceptor\";\n\n/**\n *\n * @param {string} method\n * @param {Type<*>} interceptor\n * @param options\n * @returns {(injector: InjectorService, instance: any) => void}\n */\nexport function interceptorInvokeFactory(method: string, interceptor: Type<any & IInterceptor>, options?: any) {\n  return (injector: InjectorService, target: any) => {\n    if (injector.has(interceptor)) {\n      const originalMethod = target[method];\n      const intcpt = injector.get<IInterceptor>(interceptor)!;\n\n      function interceptedMethod(...args: any[]) {\n        const context = {\n          target,\n          method,\n          args,\n          proceed(err?: Error) {\n            if (!err) {\n              return originalMethod.apply(target, args);\n            }\n\n            throw err;\n          }\n        };\n\n        return intcpt.aroundInvoke(context, options);\n      }\n\n      target[method] = interceptedMethod;\n    }\n  };\n}\n"],"sourceRoot":"../../../src"}