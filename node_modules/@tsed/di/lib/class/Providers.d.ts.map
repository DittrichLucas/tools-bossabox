{"version":3,"sources":["class/Providers.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,QAAQ,EAAE,WAAW,EAAE,IAAI,EAAC,MAAM,YAAY,CAAC;AACvD,OAAO,EAAC,SAAS,EAAE,sBAAsB,EAAC,MAAM,eAAe,CAAC;AAChE,OAAO,EAAC,gBAAgB,EAAC,MAAM,gCAAgC,CAAC;AAChE,OAAO,EAAC,QAAQ,EAAC,MAAM,YAAY,CAAC;AAEpC,qBAAa,SAAU,SAAQ,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC;IACpE;;;OAGG;IACH,OAAO,CAAC,WAAW,CAA4C;;IAM/D;;;;;;OAMG;IACH,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,OAAO,CAAC,gBAAgB,CAAC,GAAG,sBAAsB;IAoBpH;;;;OAIG;IACH,mBAAmB,CAAC,MAAM,EAAE,MAAM,GAAG,WAAW,GAAG,gBAAgB;IAuBnE;;;OAGG;IACH,gBAAgB,CAAC,IAAI,EAAE,MAAM;IAa7B;;;;OAIG;IACH,WAAW,CAAC,MAAM,EAAE,MAAM,GAAG,WAAW,GAAG,sBAAsB;CAGlE","file":"Providers.d.ts","sourcesContent":["import {Registry, RegistryKey, Type} from \"@tsed/core\";\nimport {IProvider, TypedProvidersRegistry} from \"../interfaces\";\nimport {RegistrySettings} from \"../interfaces/RegistrySettings\";\nimport {Provider} from \"./Provider\";\n\nexport class Providers extends Registry<Provider<any>, IProvider<any>> {\n  /**\n   * Internal Map\n   * @type {Array}\n   */\n  private _registries: Map<string, RegistrySettings> = new Map();\n\n  constructor() {\n    super(Provider);\n  }\n\n  /**\n   *\n   * @param {string} type\n   * @param {Type<Provider<any>>} model\n   * @param options\n   * @returns {Registry<Provider<any>, IProvider<any>>}\n   */\n  createRegistry(type: string, model: Type<Provider<any>>, options: Partial<RegistrySettings>): TypedProvidersRegistry {\n    const registry = new Registry<Provider<any>, IProvider<any>>(model, {\n      onCreate: this.set.bind(this)\n    });\n\n    this._registries.set(\n      type,\n      Object.assign(\n        {\n          registry,\n          injectable: true,\n          buildable: true\n        },\n        options\n      )\n    );\n\n    return registry;\n  }\n\n  /**\n   *\n   * @param {string | RegistryKey} target\n   * @returns {RegistrySettings | undefined}\n   */\n  getRegistrySettings(target: string | RegistryKey): RegistrySettings {\n    let type: string = \"provider\";\n\n    if (typeof target === \"string\") {\n      type = target;\n    } else {\n      const provider = this.get(target);\n      if (provider) {\n        type = provider.type;\n      }\n    }\n\n    if (this._registries.has(type)) {\n      return this._registries.get(type)!;\n    }\n\n    return {\n      registry: this,\n      injectable: true,\n      buildable: true\n    };\n  }\n\n  /**\n   *\n   * @returns {(provider: (any | IProvider<any>), instance?: any) => void}\n   */\n  createRegisterFn(type: string) {\n    return (provider: any | IProvider<any>, instance?: any): void => {\n      if (!provider.provide) {\n        provider = {\n          provide: provider\n        };\n      }\n\n      provider = Object.assign({instance}, provider, {type});\n      this.getRegistry(type).merge(provider.provide, provider);\n    };\n  }\n\n  /**\n   *\n   * @param {string | RegistryKey} target\n   * @returns {Registry<Provider<any>, IProvider<any>>}\n   */\n  getRegistry(target: string | RegistryKey): TypedProvidersRegistry {\n    return this.getRegistrySettings(target).registry;\n  }\n}\n"],"sourceRoot":"../../src"}