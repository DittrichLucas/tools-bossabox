import { RegistryKey, Type } from "@tsed/core";
import { Provider } from "../class/Provider";
import { IInjectableMethod, ProviderScope } from "../interfaces";
import { ProviderType } from "../interfaces/ProviderType";
export interface IDISettings {
    get(key: string): any;
    set(key: string, value: any): this;
    [key: string]: any;
}
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/common";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services is imported you can load InjectorService.
 * const injector = new InjectorService()
 * injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 *
 * > Note: `ServerLoader` make this automatically when you use `ServerLoader.mount()` method (or settings attributes) and load services and controllers during the starting server.
 *
 */
export declare class InjectorService extends Map<RegistryKey, Provider<any>> {
    private _settings;
    private _scopes;
    constructor();
    scopes: {
        [key: string]: ProviderScope;
    };
    settings: IDISettings;
    scopeOf(providerType: ProviderType): ProviderScope;
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param target The class or symbol registered in InjectorService.
     * @returns {boolean}
     */
    get<T>(target: Type<T> | symbol | any): T | undefined;
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @param key
     * @returns {boolean}
     */
    has(key: RegistryKey): boolean;
    /**
     * The getProvider() method returns a specified element from a Map object.
     * @param key Required. The key of the element to return from the Map object.
     * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
     */
    getProvider(key: RegistryKey): Provider<any> | undefined;
    /**
     *
     * @param {RegistryKey} key
     * @param instance
     */
    forkProvider(key: RegistryKey, instance?: any): Provider<any>;
    /**
     *
     * @param {ProviderType} type
     * @returns {[RegistryKey , Provider<any>][]}
     */
    getProviders(type?: ProviderType | string): Provider<any>[];
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param target The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param designParamTypes Optional object. List of injectable types.
     * @param requiredScope
     * @returns {T} The class constructed.
     */
    invoke<T>(target: any, locals?: Map<string | Function, any>, designParamTypes?: any[], requiredScope?: boolean): T;
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     *
     * class MyService {
     *      constructor(injectorService: InjectorService) {
     *          injectorService.invokeMethod(this.method, {
     *              this,
     *              methodName: 'method'
     *          });
     *      }
     *
     *   method(otherService: OtherService) {}
     * }
     * ```
     *
     * @returns {any}
     * @param handler The injectable method to invoke. Method parameters are injected according method signature.
     * @param options Object to configure the invocation.
     */
    invokeMethod(handler: any, options: IInjectableMethod<any>): any;
    /**
     * Initialize injectorService and load all services/factories.
     */
    load(): Promise<any>;
    /**
     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).
     * @param eventName The event name to emit at all services.
     * @param args List of the parameters to give to each services.
     * @returns {Promise<any[]>} A list of promises.
     */
    emit(eventName: string, ...args: any[]): Promise<void>;
    /**
     *
     */
    private initInjector;
    /**
     *
     * @returns {any}
     * @param options
     */
    private mapServices;
    /**
     *
     * @param instance
     */
    private bindInjectableProperties;
    /**
     *
     * @param instance
     * @param {string} propertyKey
     */
    private bindMethod;
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    private bindProperty;
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    private bindValue;
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    private bindConstant;
    /**
     *
     * @param {string} eventName
     * @param result
     * @param {string} service
     */
    /**
     *
     * @returns {Map<Type<any>, any>}
     */
    private build;
}
