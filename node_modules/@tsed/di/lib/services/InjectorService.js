"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const ts_log_debug_1 = require("ts-log-debug");
const InjectionError_1 = require("../errors/InjectionError");
const InjectionScopeError_1 = require("../errors/InjectionScopeError");
const interfaces_1 = require("../interfaces");
const ProviderRegistry_1 = require("../registries/ProviderRegistry");
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/common";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services is imported you can load InjectorService.
 * const injector = new InjectorService()
 * injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 *
 * > Note: `ServerLoader` make this automatically when you use `ServerLoader.mount()` method (or settings attributes) and load services and controllers during the starting server.
 *
 */
class InjectorService extends Map {
    constructor() {
        super();
        this._settings = new Map();
        this._scopes = {};
        this.initInjector();
    }
    get scopes() {
        return this._scopes || {};
    }
    set scopes(scopes) {
        this._scopes = scopes;
    }
    get settings() {
        return this._settings;
    }
    set settings(settings) {
        this._settings = settings;
    }
    scopeOf(providerType) {
        return this.scopes[providerType] || interfaces_1.ProviderScope.SINGLETON;
    }
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param target The class or symbol registered in InjectorService.
     * @returns {boolean}
     */
    get(target) {
        return (super.has(target) && super.get(core_1.getClassOrSymbol(target)).instance) || undefined;
    }
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @param key
     * @returns {boolean}
     */
    has(key) {
        return super.has(core_1.getClassOrSymbol(key)) && !!this.get(key);
    }
    /**
     * The getProvider() method returns a specified element from a Map object.
     * @param key Required. The key of the element to return from the Map object.
     * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
     */
    getProvider(key) {
        return super.get(core_1.getClassOrSymbol(key));
    }
    /**
     *
     * @param {RegistryKey} key
     * @param instance
     */
    forkProvider(key, instance) {
        const provider = ProviderRegistry_1.GlobalProviders.get(key).clone();
        this.set(key, provider);
        provider.instance = instance;
        return provider;
    }
    /**
     *
     * @param {ProviderType} type
     * @returns {[RegistryKey , Provider<any>][]}
     */
    getProviders(type) {
        return Array.from(this)
            .filter(([key, provider]) => (type ? provider.type === type : true))
            .map(([key, provider]) => provider);
    }
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param target The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param designParamTypes Optional object. List of injectable types.
     * @param requiredScope
     * @returns {T} The class constructed.
     */
    invoke(target, locals = new Map(), designParamTypes, requiredScope = false) {
        const { onInvoke } = ProviderRegistry_1.GlobalProviders.getRegistrySettings(target);
        const provider = this.getProvider(target);
        const parentScope = core_1.Store.from(target).get("scope");
        if (!designParamTypes) {
            designParamTypes = core_1.Metadata.getParamTypes(target);
        }
        if (provider && onInvoke) {
            onInvoke(provider, locals, designParamTypes);
        }
        const services = designParamTypes.map(serviceType => this.mapServices({
            serviceType,
            target,
            locals,
            requiredScope,
            parentScope
        }));
        const instance = new target(...services);
        this.bindInjectableProperties(instance);
        return instance;
    }
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     *
     * class MyService {
     *      constructor(injectorService: InjectorService) {
     *          injectorService.invokeMethod(this.method, {
     *              this,
     *              methodName: 'method'
     *          });
     *      }
     *
     *   method(otherService: OtherService) {}
     * }
     * ```
     *
     * @returns {any}
     * @param handler The injectable method to invoke. Method parameters are injected according method signature.
     * @param options Object to configure the invocation.
     */
    invokeMethod(handler, options) {
        let { designParamTypes } = options;
        const { locals = new Map(), target, methodName } = options;
        if (handler.$injected) {
            return handler.call(target, locals);
        }
        if (!designParamTypes) {
            designParamTypes = core_1.Metadata.getParamTypes(core_1.prototypeOf(target), methodName);
        }
        const services = designParamTypes.map((serviceType) => this.mapServices({
            serviceType,
            target,
            locals,
            requiredScope: false,
            parentScope: false
        }));
        return handler(...services);
    }
    /**
     * Initialize injectorService and load all services/factories.
     */
    load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO copy all provider from GlobalProvider registry. In future this action will be performed from Bootstrap class
            ProviderRegistry_1.GlobalProviders.forEach((p, k) => {
                if (!this.has(k)) {
                    this.set(k, p.clone());
                }
            });
            this.build();
            return Promise.all([this.emit("$onInit")]);
        });
    }
    /**
     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).
     * @param eventName The event name to emit at all services.
     * @param args List of the parameters to give to each services.
     * @returns {Promise<any[]>} A list of promises.
     */
    emit(eventName, ...args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const promises = [];
            ts_log_debug_1.$log.debug("\x1B[1mCall hook", eventName, "\x1B[22m");
            const providers = this.getProviders();
            for (const provider of providers) {
                const service = provider.instance;
                if (service && eventName in service) {
                    const startTime = new Date().getTime();
                    ts_log_debug_1.$log.debug(`Call ${core_1.nameOf(provider.provide)}.${eventName}()`);
                    yield service[eventName](...args);
                    ts_log_debug_1.$log.debug(`Run ${core_1.nameOf(provider.provide)}.${eventName}() in ${new Date().getTime() - startTime} ms`);
                }
            }
        });
    }
    /**
     *
     */
    initInjector() {
        this.forkProvider(InjectorService, this);
    }
    /**
     *
     * @returns {any}
     * @param options
     */
    mapServices(options) {
        const { serviceType, target, locals, parentScope, requiredScope } = options;
        const serviceName = typeof serviceType === "function" ? core_1.nameOf(serviceType) : serviceType;
        const localService = locals.get(serviceName) || locals.get(serviceType);
        if (localService) {
            return localService;
        }
        const provider = this.getProvider(serviceType);
        if (!provider) {
            throw new InjectionError_1.InjectionError(target, serviceName.toString());
        }
        const { buildable, injectable } = ProviderRegistry_1.GlobalProviders.getRegistrySettings(provider.type);
        const scopeReq = provider.scope === interfaces_1.ProviderScope.REQUEST;
        if (!injectable) {
            throw new InjectionError_1.InjectionError(target, serviceName.toString(), "not injectable");
        }
        if (!buildable || (provider.instance && !scopeReq)) {
            return provider.instance;
        }
        if (scopeReq && requiredScope && !parentScope) {
            throw new InjectionScopeError_1.InjectionScopeError(provider.useClass, target);
        }
        try {
            const instance = this.invoke(provider.useClass, locals, undefined, requiredScope);
            locals.set(provider.provide, instance);
            return instance;
        }
        catch (er) {
            const error = new InjectionError_1.InjectionError(target, serviceName.toString(), "injection failed");
            error.origin = er;
            throw error;
        }
    }
    /**
     *
     * @param instance
     */
    bindInjectableProperties(instance) {
        const properties = core_1.Store.from(core_1.getClass(instance)).get("injectableProperties") || [];
        Object.keys(properties)
            .map(key => properties[key])
            .forEach(definition => {
            switch (definition.bindingType) {
                case "method":
                    this.bindMethod(instance, definition);
                    break;
                case "property":
                    this.bindProperty(instance, definition);
                    break;
                case "constant":
                    this.bindConstant(instance, definition);
                    break;
                case "value":
                    this.bindValue(instance, definition);
                    break;
                case "custom":
                    definition.onInvoke(this, instance, definition);
                    break;
            }
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     */
    bindMethod(instance, { propertyKey }) {
        const target = core_1.getClass(instance);
        const originalMethod = instance[propertyKey];
        instance[propertyKey] = (locals = new Map()) => {
            return this.invokeMethod(originalMethod.bind(instance), {
                target,
                methodName: propertyKey,
                locals: locals instanceof Map ? locals : undefined
            });
        };
        instance[propertyKey].$injected = true;
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindProperty(instance, { propertyKey, useType }) {
        Object.defineProperty(instance, propertyKey, {
            get: () => {
                return this.get(useType);
            }
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindValue(instance, { propertyKey, expression, defaultValue }) {
        const descriptor = {
            get: () => this.settings.get(expression) || defaultValue,
            set: (value) => this.settings.set(expression, value),
            enumerable: true,
            configurable: true
        };
        Object.defineProperty(instance, propertyKey, descriptor);
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindConstant(instance, { propertyKey, expression, defaultValue }) {
        const clone = (o) => {
            if (o) {
                return Object.freeze(core_1.deepClone(o));
            }
            return defaultValue;
        };
        const descriptor = {
            get: () => clone(this.settings.get(expression)),
            enumerable: true,
            configurable: true
        };
        Object.defineProperty(instance, propertyKey, descriptor);
        return descriptor;
    }
    /**
     *
     * @param {string} eventName
     * @param result
     * @param {string} service
     */
    /**
     *
     * @returns {Map<Type<any>, any>}
     */
    build() {
        const locals = new Map();
        this.forEach(provider => {
            const token = core_1.nameOf(provider.provide);
            const settings = ProviderRegistry_1.GlobalProviders.getRegistrySettings(provider.type);
            const useClass = core_1.nameOf(provider.useClass);
            if (settings.buildable) {
                const defaultScope = this.scopeOf(provider.type);
                if (defaultScope && !provider.scope) {
                    provider.scope = defaultScope;
                }
                if (!locals.has(provider.provide)) {
                    provider.instance = this.invoke(provider.useClass, locals);
                }
                else if (provider.scope === interfaces_1.ProviderScope.SINGLETON) {
                    provider.instance = locals.get(provider.provide);
                }
                ts_log_debug_1.$log.debug(core_1.nameOf(provider.provide), "built", token === useClass ? "" : `from class ${useClass}`);
            }
            else {
                provider.scope = interfaces_1.ProviderScope.SINGLETON;
                ts_log_debug_1.$log.debug(core_1.nameOf(provider.provide), "loaded");
            }
            if (provider.instance) {
                locals.set(provider.provide, provider.instance);
            }
        });
        return locals;
    }
}
exports.InjectorService = InjectorService;
/**
 * Create the first service InjectorService
 */
ProviderRegistry_1.registerFactory(InjectorService);

//# sourceMappingURL=InjectorService.js.map
