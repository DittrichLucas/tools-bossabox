{"version":3,"sources":["services/InjectorService.ts"],"names":[],"mappings":"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","file":"InjectorService.js","sourcesContent":["import {getClass, getClassOrSymbol, Metadata, nameOf, prototypeOf, RegistryKey, Store, Type, deepClone} from \"@tsed/core\";\nimport {$log} from \"ts-log-debug\";\nimport {Provider} from \"../class/Provider\";\nimport {InjectionError} from \"../errors/InjectionError\";\nimport {InjectionScopeError} from \"../errors/InjectionScopeError\";\nimport {IInjectableMethod, ProviderScope} from \"../interfaces\";\nimport {IInjectableProperties, IInjectablePropertyService, IInjectablePropertyValue} from \"../interfaces/IInjectableProperties\";\nimport {ProviderType} from \"../interfaces/ProviderType\";\nimport {GlobalProviders, registerFactory} from \"../registries/ProviderRegistry\";\n\nexport interface IDISettings {\n  get(key: string): any;\n\n  set(key: string, value: any): this;\n\n  [key: string]: any;\n}\n\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/common\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services is imported you can load InjectorService.\n * const injector = new InjectorService()\n * injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n *\n * > Note: `ServerLoader` make this automatically when you use `ServerLoader.mount()` method (or settings attributes) and load services and controllers during the starting server.\n *\n */\nexport class InjectorService extends Map<RegistryKey, Provider<any>> {\n  private _settings: IDISettings = new Map();\n  private _scopes: {[key: string]: ProviderScope} = {};\n\n  constructor() {\n    super();\n    this.initInjector();\n  }\n\n  get scopes(): {[key: string]: ProviderScope} {\n    return this._scopes || {};\n  }\n\n  set scopes(scopes: {[key: string]: ProviderScope}) {\n    this._scopes = scopes;\n  }\n\n  get settings() {\n    return this._settings;\n  }\n\n  set settings(settings: IDISettings) {\n    this._settings = settings;\n  }\n\n  scopeOf(providerType: ProviderType) {\n    return this.scopes[providerType] || ProviderScope.SINGLETON;\n  }\n\n  /**\n   * Get a service or factory already constructed from his symbol or class.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *      constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.get<MyService>(MyService);\n   *      }\n   * }\n   * ```\n   *\n   * @param target The class or symbol registered in InjectorService.\n   * @returns {boolean}\n   */\n  get<T>(target: Type<T> | symbol | any): T | undefined {\n    return (super.has(target) && super.get(getClassOrSymbol(target))!.instance) || undefined;\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key\n   * @returns {boolean}\n   */\n  has(key: RegistryKey): boolean {\n    return super.has(getClassOrSymbol(key)) && !!this.get(key);\n  }\n\n  /**\n   * The getProvider() method returns a specified element from a Map object.\n   * @param key Required. The key of the element to return from the Map object.\n   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n   */\n  getProvider(key: RegistryKey): Provider<any> | undefined {\n    return super.get(getClassOrSymbol(key));\n  }\n\n  /**\n   *\n   * @param {RegistryKey} key\n   * @param instance\n   */\n  forkProvider(key: RegistryKey, instance?: any): Provider<any> {\n    const provider = GlobalProviders.get(key)!.clone();\n    this.set(key, provider);\n\n    provider.instance = instance;\n\n    return provider;\n  }\n\n  /**\n   *\n   * @param {ProviderType} type\n   * @returns {[RegistryKey , Provider<any>][]}\n   */\n  getProviders(type?: ProviderType | string): Provider<any>[] {\n    return Array.from(this)\n      .filter(([key, provider]) => (type ? provider.type === type : true))\n      .map(([key, provider]) => provider);\n  }\n\n  /**\n   * Invoke the class and inject all services that required by the class constructor.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *     constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.invoke<MyService>(MyService);\n   *      }\n   *  }\n   * ```\n   *\n   * @param target The injectable class to invoke. Class parameters are injected according constructor signature.\n   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   * @param designParamTypes Optional object. List of injectable types.\n   * @param requiredScope\n   * @returns {T} The class constructed.\n   */\n  invoke<T>(target: any, locals: Map<string | Function, any> = new Map(), designParamTypes?: any[], requiredScope: boolean = false): T {\n    const {onInvoke} = GlobalProviders.getRegistrySettings(target);\n    const provider = this.getProvider(target);\n    const parentScope = Store.from(target).get(\"scope\");\n\n    if (!designParamTypes) {\n      designParamTypes = Metadata.getParamTypes(target);\n    }\n\n    if (provider && onInvoke) {\n      onInvoke(provider, locals, designParamTypes);\n    }\n\n    const services = designParamTypes.map(serviceType =>\n      this.mapServices({\n        serviceType,\n        target,\n        locals,\n        requiredScope,\n        parentScope\n      })\n    );\n\n    const instance = new target(...services);\n\n    this.bindInjectableProperties(instance);\n\n    return instance;\n  }\n\n  /**\n   * Invoke a class method and inject service.\n   *\n   * #### IInjectableMethod options\n   *\n   * * **target**: Optional. The class instance.\n   * * **methodName**: `string` Optional. The method name.\n   * * **designParamTypes**: `any[]` Optional. List of injectable types.\n   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   *\n   * class MyService {\n   *      constructor(injectorService: InjectorService) {\n   *          injectorService.invokeMethod(this.method, {\n   *              this,\n   *              methodName: 'method'\n   *          });\n   *      }\n   *\n   *   method(otherService: OtherService) {}\n   * }\n   * ```\n   *\n   * @returns {any}\n   * @param handler The injectable method to invoke. Method parameters are injected according method signature.\n   * @param options Object to configure the invocation.\n   */\n  public invokeMethod(handler: any, options: IInjectableMethod<any>): any {\n    let {designParamTypes} = options;\n    const {locals = new Map<any, any>(), target, methodName} = options;\n\n    if (handler.$injected) {\n      return handler.call(target, locals);\n    }\n\n    if (!designParamTypes) {\n      designParamTypes = Metadata.getParamTypes(prototypeOf(target), methodName);\n    }\n\n    const services = designParamTypes.map((serviceType: any) =>\n      this.mapServices({\n        serviceType,\n        target,\n        locals,\n        requiredScope: false,\n        parentScope: false\n      })\n    );\n\n    return handler(...services);\n  }\n\n  /**\n   * Initialize injectorService and load all services/factories.\n   */\n  async load(): Promise<any> {\n    // TODO copy all provider from GlobalProvider registry. In future this action will be performed from Bootstrap class\n    GlobalProviders.forEach((p, k) => {\n      if (!this.has(k)) {\n        this.set(k, p.clone());\n      }\n    });\n\n    this.build();\n\n    return Promise.all([this.emit(\"$onInit\")]);\n  }\n\n  /**\n   * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).\n   * @param eventName The event name to emit at all services.\n   * @param args List of the parameters to give to each services.\n   * @returns {Promise<any[]>} A list of promises.\n   */\n  public async emit(eventName: string, ...args: any[]) {\n    const promises: Promise<any>[] = [];\n\n    $log.debug(\"\\x1B[1mCall hook\", eventName, \"\\x1B[22m\");\n\n    const providers = this.getProviders();\n\n    for (const provider of providers) {\n      const service = provider.instance;\n\n      if (service && eventName in service) {\n        const startTime = new Date().getTime();\n        $log.debug(`Call ${nameOf(provider.provide)}.${eventName}()`);\n\n        await service[eventName](...args);\n\n        $log.debug(`Run ${nameOf(provider.provide)}.${eventName}() in ${new Date().getTime() - startTime} ms`);\n      }\n    }\n  }\n\n  /**\n   *\n   */\n  private initInjector() {\n    this.forkProvider(InjectorService, this);\n  }\n\n  /**\n   *\n   * @returns {any}\n   * @param options\n   */\n  private mapServices(options: any) {\n    const {serviceType, target, locals, parentScope, requiredScope} = options;\n    const serviceName = typeof serviceType === \"function\" ? nameOf(serviceType) : serviceType;\n    const localService = locals.get(serviceName) || locals.get(serviceType);\n\n    if (localService) {\n      return localService;\n    }\n\n    const provider = this.getProvider(serviceType);\n\n    if (!provider) {\n      throw new InjectionError(target, serviceName.toString());\n    }\n\n    const {buildable, injectable} = GlobalProviders.getRegistrySettings(provider.type);\n    const scopeReq = provider.scope === ProviderScope.REQUEST;\n\n    if (!injectable) {\n      throw new InjectionError(target, serviceName.toString(), \"not injectable\");\n    }\n\n    if (!buildable || (provider.instance && !scopeReq)) {\n      return provider.instance;\n    }\n\n    if (scopeReq && requiredScope && !parentScope) {\n      throw new InjectionScopeError(provider.useClass, target);\n    }\n\n    try {\n      const instance = this.invoke<any>(provider.useClass, locals, undefined, requiredScope);\n      locals.set(provider.provide, instance);\n\n      return instance;\n    } catch (er) {\n      const error = new InjectionError(target, serviceName.toString(), \"injection failed\");\n      (error as any).origin = er;\n      throw error;\n    }\n  }\n\n  /**\n   *\n   * @param instance\n   */\n  private bindInjectableProperties(instance: any) {\n    const properties: IInjectableProperties = Store.from(getClass(instance)).get(\"injectableProperties\") || [];\n\n    Object.keys(properties)\n      .map(key => properties[key])\n      .forEach(definition => {\n        switch (definition.bindingType) {\n          case \"method\":\n            this.bindMethod(instance, definition);\n            break;\n          case \"property\":\n            this.bindProperty(instance, definition);\n            break;\n          case \"constant\":\n            this.bindConstant(instance, definition);\n            break;\n          case \"value\":\n            this.bindValue(instance, definition);\n            break;\n          case \"custom\":\n            definition.onInvoke(this, instance, definition);\n            break;\n        }\n      });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   */\n  private bindMethod(instance: any, {propertyKey}: IInjectablePropertyService) {\n    const target = getClass(instance);\n    const originalMethod = instance[propertyKey];\n\n    instance[propertyKey] = (locals: Map<Function, string> | any = new Map<Function, string>()) => {\n      return this.invokeMethod(originalMethod!.bind(instance), {\n        target,\n        methodName: propertyKey,\n        locals: locals instanceof Map ? locals : undefined\n      });\n    };\n\n    instance[propertyKey].$injected = true;\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindProperty(instance: any, {propertyKey, useType}: IInjectablePropertyService) {\n    Object.defineProperty(instance, propertyKey, {\n      get: () => {\n        return this.get(useType);\n      }\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindValue(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const descriptor = {\n      get: () => this.settings.get(expression) || defaultValue,\n      set: (value: any) => this.settings.set(expression, value),\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindConstant(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const clone = (o: any) => {\n      if (o) {\n        return Object.freeze(deepClone(o));\n      }\n\n      return defaultValue;\n    };\n\n    const descriptor = {\n      get: () => clone(this.settings.get(expression)),\n\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n\n    return descriptor;\n  }\n\n  /**\n   *\n   * @param {string} eventName\n   * @param result\n   * @param {string} service\n   */\n\n  /**\n   *\n   * @returns {Map<Type<any>, any>}\n   */\n  private build(): Map<Type<any>, any> {\n    const locals: Map<Type<any>, any> = new Map();\n\n    this.forEach(provider => {\n      const token = nameOf(provider.provide);\n      const settings = GlobalProviders.getRegistrySettings(provider.type);\n      const useClass = nameOf(provider.useClass);\n\n      if (settings.buildable) {\n        const defaultScope: ProviderScope = this.scopeOf(provider.type);\n\n        if (defaultScope && !provider.scope) {\n          provider.scope = defaultScope;\n        }\n\n        if (!locals.has(provider.provide)) {\n          provider.instance = this.invoke(provider.useClass, locals);\n        } else if (provider.scope === ProviderScope.SINGLETON) {\n          provider.instance = locals.get(provider.provide);\n        }\n\n        $log.debug(nameOf(provider.provide), \"built\", token === useClass ? \"\" : `from class ${useClass}`);\n      } else {\n        provider.scope = ProviderScope.SINGLETON;\n        $log.debug(nameOf(provider.provide), \"loaded\");\n      }\n\n      if (provider.instance) {\n        locals.set(provider.provide, provider.instance);\n      }\n    });\n\n    return locals;\n  }\n}\n\n/**\n * Create the first service InjectorService\n */\nregisterFactory(InjectorService);\n"],"sourceRoot":"../../src"}