{"version":3,"sources":["services/InjectorService.ts"],"names":[],"mappings":"AAAA,OAAO,EAA4D,WAAW,EAAS,IAAI,EAAY,MAAM,YAAY,CAAC;AAE1H,OAAO,EAAC,QAAQ,EAAC,MAAM,mBAAmB,CAAC;AAG3C,OAAO,EAAC,iBAAiB,EAAE,aAAa,EAAC,MAAM,eAAe,CAAC;AAE/D,OAAO,EAAC,YAAY,EAAC,MAAM,4BAA4B,CAAC;AAGxD,MAAM,WAAW,WAAW;IAC1B,GAAG,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IAEtB,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,GAAG,IAAI,CAAC;IAEnC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB;AAED;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,qBAAa,eAAgB,SAAQ,GAAG,CAAC,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC;IAClE,OAAO,CAAC,SAAS,CAA0B;IAC3C,OAAO,CAAC,OAAO,CAAsC;;IAOjD,MAAM,EAAI;QAAC,CAAC,GAAG,EAAE,MAAM,GAAG,aAAa,CAAA;KAAC;IAQxC,QAAQ,EAIW,WAAW;IAIlC,OAAO,CAAC,YAAY,EAAE,YAAY;IAIlC;;;;;;;;;;;;;;;;;;OAkBG;IACH,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,GAAG,MAAM,GAAG,GAAG,GAAG,CAAC,GAAG,SAAS;IAIrD;;;;OAIG;IACH,GAAG,CAAC,GAAG,EAAE,WAAW,GAAG,OAAO;IAI9B;;;;OAIG;IACH,WAAW,CAAC,GAAG,EAAE,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,SAAS;IAIxD;;;;OAIG;IACH,YAAY,CAAC,GAAG,EAAE,WAAW,EAAE,QAAQ,CAAC,EAAE,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC;IAS7D;;;;OAIG;IACH,YAAY,CAAC,IAAI,CAAC,EAAE,YAAY,GAAG,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,EAAE;IAM3D;;;;;;;;;;;;;;;;;;;;;OAqBG;IACH,MAAM,CAAC,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,GAAE,GAAG,CAAC,MAAM,GAAG,QAAQ,EAAE,GAAG,CAAa,EAAE,gBAAgB,CAAC,EAAE,GAAG,EAAE,EAAE,aAAa,GAAE,OAAe,GAAG,CAAC;IA8BpI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA8BG;IACI,YAAY,CAAC,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,iBAAiB,CAAC,GAAG,CAAC,GAAG,GAAG;IAyBvE;;OAEG;IACG,IAAI,IAAI,OAAO,CAAC,GAAG,CAAC;IAa1B;;;;;OAKG;IACU,IAAI,CAAC,SAAS,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE;IAqBnD;;OAEG;IACH,OAAO,CAAC,YAAY;IAIpB;;;;OAIG;IACH,OAAO,CAAC,WAAW;IA0CnB;;;OAGG;IACH,OAAO,CAAC,wBAAwB;IA0BhC;;;;OAIG;IACH,OAAO,CAAC,UAAU;IAelB;;;;;OAKG;IACH,OAAO,CAAC,YAAY;IAQpB;;;;;OAKG;IACH,OAAO,CAAC,SAAS;IAUjB;;;;;OAKG;IACH,OAAO,CAAC,YAAY;IAoBpB;;;;;OAKG;IAEH;;;OAGG;IACH,OAAO,CAAC,KAAK;CAkCd","file":"InjectorService.d.ts","sourcesContent":["import {getClass, getClassOrSymbol, Metadata, nameOf, prototypeOf, RegistryKey, Store, Type, deepClone} from \"@tsed/core\";\nimport {$log} from \"ts-log-debug\";\nimport {Provider} from \"../class/Provider\";\nimport {InjectionError} from \"../errors/InjectionError\";\nimport {InjectionScopeError} from \"../errors/InjectionScopeError\";\nimport {IInjectableMethod, ProviderScope} from \"../interfaces\";\nimport {IInjectableProperties, IInjectablePropertyService, IInjectablePropertyValue} from \"../interfaces/IInjectableProperties\";\nimport {ProviderType} from \"../interfaces/ProviderType\";\nimport {GlobalProviders, registerFactory} from \"../registries/ProviderRegistry\";\n\nexport interface IDISettings {\n  get(key: string): any;\n\n  set(key: string, value: any): this;\n\n  [key: string]: any;\n}\n\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/common\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services is imported you can load InjectorService.\n * const injector = new InjectorService()\n * injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n *\n * > Note: `ServerLoader` make this automatically when you use `ServerLoader.mount()` method (or settings attributes) and load services and controllers during the starting server.\n *\n */\nexport class InjectorService extends Map<RegistryKey, Provider<any>> {\n  private _settings: IDISettings = new Map();\n  private _scopes: {[key: string]: ProviderScope} = {};\n\n  constructor() {\n    super();\n    this.initInjector();\n  }\n\n  get scopes(): {[key: string]: ProviderScope} {\n    return this._scopes || {};\n  }\n\n  set scopes(scopes: {[key: string]: ProviderScope}) {\n    this._scopes = scopes;\n  }\n\n  get settings() {\n    return this._settings;\n  }\n\n  set settings(settings: IDISettings) {\n    this._settings = settings;\n  }\n\n  scopeOf(providerType: ProviderType) {\n    return this.scopes[providerType] || ProviderScope.SINGLETON;\n  }\n\n  /**\n   * Get a service or factory already constructed from his symbol or class.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *      constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.get<MyService>(MyService);\n   *      }\n   * }\n   * ```\n   *\n   * @param target The class or symbol registered in InjectorService.\n   * @returns {boolean}\n   */\n  get<T>(target: Type<T> | symbol | any): T | undefined {\n    return (super.has(target) && super.get(getClassOrSymbol(target))!.instance) || undefined;\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key\n   * @returns {boolean}\n   */\n  has(key: RegistryKey): boolean {\n    return super.has(getClassOrSymbol(key)) && !!this.get(key);\n  }\n\n  /**\n   * The getProvider() method returns a specified element from a Map object.\n   * @param key Required. The key of the element to return from the Map object.\n   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n   */\n  getProvider(key: RegistryKey): Provider<any> | undefined {\n    return super.get(getClassOrSymbol(key));\n  }\n\n  /**\n   *\n   * @param {RegistryKey} key\n   * @param instance\n   */\n  forkProvider(key: RegistryKey, instance?: any): Provider<any> {\n    const provider = GlobalProviders.get(key)!.clone();\n    this.set(key, provider);\n\n    provider.instance = instance;\n\n    return provider;\n  }\n\n  /**\n   *\n   * @param {ProviderType} type\n   * @returns {[RegistryKey , Provider<any>][]}\n   */\n  getProviders(type?: ProviderType | string): Provider<any>[] {\n    return Array.from(this)\n      .filter(([key, provider]) => (type ? provider.type === type : true))\n      .map(([key, provider]) => provider);\n  }\n\n  /**\n   * Invoke the class and inject all services that required by the class constructor.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *     constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.invoke<MyService>(MyService);\n   *      }\n   *  }\n   * ```\n   *\n   * @param target The injectable class to invoke. Class parameters are injected according constructor signature.\n   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   * @param designParamTypes Optional object. List of injectable types.\n   * @param requiredScope\n   * @returns {T} The class constructed.\n   */\n  invoke<T>(target: any, locals: Map<string | Function, any> = new Map(), designParamTypes?: any[], requiredScope: boolean = false): T {\n    const {onInvoke} = GlobalProviders.getRegistrySettings(target);\n    const provider = this.getProvider(target);\n    const parentScope = Store.from(target).get(\"scope\");\n\n    if (!designParamTypes) {\n      designParamTypes = Metadata.getParamTypes(target);\n    }\n\n    if (provider && onInvoke) {\n      onInvoke(provider, locals, designParamTypes);\n    }\n\n    const services = designParamTypes.map(serviceType =>\n      this.mapServices({\n        serviceType,\n        target,\n        locals,\n        requiredScope,\n        parentScope\n      })\n    );\n\n    const instance = new target(...services);\n\n    this.bindInjectableProperties(instance);\n\n    return instance;\n  }\n\n  /**\n   * Invoke a class method and inject service.\n   *\n   * #### IInjectableMethod options\n   *\n   * * **target**: Optional. The class instance.\n   * * **methodName**: `string` Optional. The method name.\n   * * **designParamTypes**: `any[]` Optional. List of injectable types.\n   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   *\n   * class MyService {\n   *      constructor(injectorService: InjectorService) {\n   *          injectorService.invokeMethod(this.method, {\n   *              this,\n   *              methodName: 'method'\n   *          });\n   *      }\n   *\n   *   method(otherService: OtherService) {}\n   * }\n   * ```\n   *\n   * @returns {any}\n   * @param handler The injectable method to invoke. Method parameters are injected according method signature.\n   * @param options Object to configure the invocation.\n   */\n  public invokeMethod(handler: any, options: IInjectableMethod<any>): any {\n    let {designParamTypes} = options;\n    const {locals = new Map<any, any>(), target, methodName} = options;\n\n    if (handler.$injected) {\n      return handler.call(target, locals);\n    }\n\n    if (!designParamTypes) {\n      designParamTypes = Metadata.getParamTypes(prototypeOf(target), methodName);\n    }\n\n    const services = designParamTypes.map((serviceType: any) =>\n      this.mapServices({\n        serviceType,\n        target,\n        locals,\n        requiredScope: false,\n        parentScope: false\n      })\n    );\n\n    return handler(...services);\n  }\n\n  /**\n   * Initialize injectorService and load all services/factories.\n   */\n  async load(): Promise<any> {\n    // TODO copy all provider from GlobalProvider registry. In future this action will be performed from Bootstrap class\n    GlobalProviders.forEach((p, k) => {\n      if (!this.has(k)) {\n        this.set(k, p.clone());\n      }\n    });\n\n    this.build();\n\n    return Promise.all([this.emit(\"$onInit\")]);\n  }\n\n  /**\n   * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).\n   * @param eventName The event name to emit at all services.\n   * @param args List of the parameters to give to each services.\n   * @returns {Promise<any[]>} A list of promises.\n   */\n  public async emit(eventName: string, ...args: any[]) {\n    const promises: Promise<any>[] = [];\n\n    $log.debug(\"\\x1B[1mCall hook\", eventName, \"\\x1B[22m\");\n\n    const providers = this.getProviders();\n\n    for (const provider of providers) {\n      const service = provider.instance;\n\n      if (service && eventName in service) {\n        const startTime = new Date().getTime();\n        $log.debug(`Call ${nameOf(provider.provide)}.${eventName}()`);\n\n        await service[eventName](...args);\n\n        $log.debug(`Run ${nameOf(provider.provide)}.${eventName}() in ${new Date().getTime() - startTime} ms`);\n      }\n    }\n  }\n\n  /**\n   *\n   */\n  private initInjector() {\n    this.forkProvider(InjectorService, this);\n  }\n\n  /**\n   *\n   * @returns {any}\n   * @param options\n   */\n  private mapServices(options: any) {\n    const {serviceType, target, locals, parentScope, requiredScope} = options;\n    const serviceName = typeof serviceType === \"function\" ? nameOf(serviceType) : serviceType;\n    const localService = locals.get(serviceName) || locals.get(serviceType);\n\n    if (localService) {\n      return localService;\n    }\n\n    const provider = this.getProvider(serviceType);\n\n    if (!provider) {\n      throw new InjectionError(target, serviceName.toString());\n    }\n\n    const {buildable, injectable} = GlobalProviders.getRegistrySettings(provider.type);\n    const scopeReq = provider.scope === ProviderScope.REQUEST;\n\n    if (!injectable) {\n      throw new InjectionError(target, serviceName.toString(), \"not injectable\");\n    }\n\n    if (!buildable || (provider.instance && !scopeReq)) {\n      return provider.instance;\n    }\n\n    if (scopeReq && requiredScope && !parentScope) {\n      throw new InjectionScopeError(provider.useClass, target);\n    }\n\n    try {\n      const instance = this.invoke<any>(provider.useClass, locals, undefined, requiredScope);\n      locals.set(provider.provide, instance);\n\n      return instance;\n    } catch (er) {\n      const error = new InjectionError(target, serviceName.toString(), \"injection failed\");\n      (error as any).origin = er;\n      throw error;\n    }\n  }\n\n  /**\n   *\n   * @param instance\n   */\n  private bindInjectableProperties(instance: any) {\n    const properties: IInjectableProperties = Store.from(getClass(instance)).get(\"injectableProperties\") || [];\n\n    Object.keys(properties)\n      .map(key => properties[key])\n      .forEach(definition => {\n        switch (definition.bindingType) {\n          case \"method\":\n            this.bindMethod(instance, definition);\n            break;\n          case \"property\":\n            this.bindProperty(instance, definition);\n            break;\n          case \"constant\":\n            this.bindConstant(instance, definition);\n            break;\n          case \"value\":\n            this.bindValue(instance, definition);\n            break;\n          case \"custom\":\n            definition.onInvoke(this, instance, definition);\n            break;\n        }\n      });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   */\n  private bindMethod(instance: any, {propertyKey}: IInjectablePropertyService) {\n    const target = getClass(instance);\n    const originalMethod = instance[propertyKey];\n\n    instance[propertyKey] = (locals: Map<Function, string> | any = new Map<Function, string>()) => {\n      return this.invokeMethod(originalMethod!.bind(instance), {\n        target,\n        methodName: propertyKey,\n        locals: locals instanceof Map ? locals : undefined\n      });\n    };\n\n    instance[propertyKey].$injected = true;\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindProperty(instance: any, {propertyKey, useType}: IInjectablePropertyService) {\n    Object.defineProperty(instance, propertyKey, {\n      get: () => {\n        return this.get(useType);\n      }\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindValue(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const descriptor = {\n      get: () => this.settings.get(expression) || defaultValue,\n      set: (value: any) => this.settings.set(expression, value),\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindConstant(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const clone = (o: any) => {\n      if (o) {\n        return Object.freeze(deepClone(o));\n      }\n\n      return defaultValue;\n    };\n\n    const descriptor = {\n      get: () => clone(this.settings.get(expression)),\n\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n\n    return descriptor;\n  }\n\n  /**\n   *\n   * @param {string} eventName\n   * @param result\n   * @param {string} service\n   */\n\n  /**\n   *\n   * @returns {Map<Type<any>, any>}\n   */\n  private build(): Map<Type<any>, any> {\n    const locals: Map<Type<any>, any> = new Map();\n\n    this.forEach(provider => {\n      const token = nameOf(provider.provide);\n      const settings = GlobalProviders.getRegistrySettings(provider.type);\n      const useClass = nameOf(provider.useClass);\n\n      if (settings.buildable) {\n        const defaultScope: ProviderScope = this.scopeOf(provider.type);\n\n        if (defaultScope && !provider.scope) {\n          provider.scope = defaultScope;\n        }\n\n        if (!locals.has(provider.provide)) {\n          provider.instance = this.invoke(provider.useClass, locals);\n        } else if (provider.scope === ProviderScope.SINGLETON) {\n          provider.instance = locals.get(provider.provide);\n        }\n\n        $log.debug(nameOf(provider.provide), \"built\", token === useClass ? \"\" : `from class ${useClass}`);\n      } else {\n        provider.scope = ProviderScope.SINGLETON;\n        $log.debug(nameOf(provider.provide), \"loaded\");\n      }\n\n      if (provider.instance) {\n        locals.set(provider.provide, provider.instance);\n      }\n    });\n\n    return locals;\n  }\n}\n\n/**\n * Create the first service InjectorService\n */\nregisterFactory(InjectorService);\n"],"sourceRoot":"../../src"}